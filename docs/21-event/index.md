# 事件

Symfony 作為一個完整的生態系統，定義了數十個組件，每個組件都有不同的功能。

在 Symfony 之外，當然還有其他生態系統，定義了其他功能的套件（如 Doctrine、Twig 等）。

## 可擴展性

於是，現在面臨的問題是如何使所有這些**單獨定義**的套件具有可擴展性？ 當我們談論可擴展性時，我們談論的是在最初由套件的創建者預先定義的行為基礎上添加特定行為，有點類似於**繼承**。

但有時，繼承會有其限制。

比方說，如果我想在特定時刻執行操作，例如在將一行資料儲存到資料庫之前，我應該繼承一個 `EntityManager` 來包含我的功能嗎？ 還是我應該在呼叫 `persist` 和 `flush` 方法之前直接執行我的行為？

如果我選擇了第二種解決方案，那麼如果我在應用程式的多個地方都需要這個行為，該怎麼辦呢？

## 事件系統

事件通常源自於我們所稱之為**設計模式**的概念。 設計模式有時能夠幫助我們透過特定的解決方案解決問題。

例如，事件系統允許我們在應用程式中定義我們將允許執行其他程式碼的點。

為此，我們將在應用程式中某個時刻傳播一個**事件**。 然後，程式碼的另一部分可以**監聽此事**件，並在事件傳播時執行。

讓我們以上面的範例為例：Doctrine 定義了一個名為 `prePersist` 的事件，在將行儲存到資料庫之前會自動傳播。 然後，我們可以定義一個類別來**監聽**此事件，並在儲存行之前自動觸發。

:::note 觀察者模式
事件系統來自[觀察者設計模式](https://en.wikipedia.org/wiki/Observer_pattern)。
:::

## 派發事件

在 Symfony 生態系統中，`symfony/event-dispatcher` 元件允許在應用程式內註冊和呼叫事件。 我們使用事件派發器（dispatcher）來在應用程式中傳播事件。

實際上，我們的應用程式已經經常發出事件。 因此，我們將看看如何監聽這些事件，以及如何發出我們自己的事件。

:::note 中介者
事件調度器源自[中介者（Mediator）](https://en.wikipedia.org/wiki/Mediator_pattern)設計模式。
:::
